(num, str, bin) -> {
    #`+` = num.add
    #`-` = num.subtract

    elfclass = {
        class_none = 0
        class_32 = 1
        class_64 = 2
    }
    elfdata = {
        data_none = 0
        data_2LSB = 1
        data_2MSB = 2
    }
    ev = {
        none    = 0
        current = 1
    }
    osabi = {
        sysv    = 0x00
        hpux    = 0x01
        netbsd  = 0x02
        linux   = 0x03
        solaris = 0x06
        aix     = 0x07
        irix    = 0x08
        freebsd = 0x09
        tru64   = 0x0A
        modesto = 0x0B
        openbsd = 0x0C
        openvms = 0x0D
        nsk     = 0x0E
        standalone = 0xFF
    }
    et = {
        none = 0
        rel  = 1
        exec = 2
        dyn  = 3
        core = 4
        loos   = 0xFE00
        hios   = 0xFEFF
        loproc = 0xFF00
        hiproc = 0xFFFF
    }
    machine = {
        sparc   = 0x02
        x86     = 0x03
        mips    = 0x08
        ppc     = 0x14
        arm     = 0x28
        superh  = 0x2A
        ia_64   = 0x32
        x86_64  = 0x3E
        aarch64 = 0xB7
    }

    pt = {
        null    = 0
        load    = 1
        dynamic = 2
        interp  = 3
        note    = 4
        shlib   = 5
        phdr    = 6
        loos    = 0x60000000
        hios    = 0x6FFFFFFF
        loproc  = 0x70000000
        hiproc  = 0x7FFFFFFF
    }
    pf = {
        x = 0x1
        w = 0x2
        r = 0x4
        maskos   = 0x00FF0000
        maskproc = 0xFF000000
    }
    program_header_entry = (phe) -> {
        bin.u32(phe.type)
        bin.u32(phe.flags)
        bin.u64(phe.offset)
        bin.u64(phe.vaddr)
        bin.u64(phe.paddr)
        bin.u64(phe.filesz)
        bin.u64(phe.memsz)
        bin.u64(phe.align)
    }

    shn = {
        undef  = 0
        loproc = 0xFF00
        hiproc = 0xFF1F
        loos   = 0xFF20
        hios   = 0xFF3F
        abs    = 0xFFF1
        common = 0xFFF2
    }
    sht = {
        null = 0
        progbits = 1
        symtab = 2
        strtab = 3
        rela = 4
        hash = 5
        dynamic = 6
        note = 7
        nobits = 8
        rel = 9
        shlib = 10
        dynsym = 11
        loos   = 0x60000000
        hios   = 0x6FFFFFFF
        loproc = 0x70000000
        hiproc = 0x7FFFFFFF
    }
    shf = {
        write = 0x1
        alloc = 0x2
        execinstr = 0x4
        maskos   = 0x0F000000
        maskproc = 0xF0000000
    }

    # TODO: noexec stack
    # TODO: sections, should have:
    # r-x text
    # rw- stack
    # rw- data
    # rw- bss
    # r-- rodata

    section_header_entry = (she) -> {
        bin.u32(she.name)
        bin.u32(she.type)
        bin.u64(she.flags)
        bin.u64(she.addr)
        bin.u64(she.offset)
        bin.u64(she.size)
        bin.u32(she.link)
        bin.u32(she.info)
        bin.u64(she.addralign)
        bin.u64(she.entsize)
    }

    # Thanks to muppetlabs.com for the Whirlwind Tutorial on Creating
    # Really Teensy ELF Executables for Linux :)
    linux_x64 = (rodata, data, bss, text) -> {
        mem_offset = 0x00400000
        binsize = num.subtract(end, beginning)

        repositioned_rodata = WithPosition(num.add(mem_offset, rodata_offset), rodata)
        repositioned_data   = WithPosition(num.add(mem_offset, data_offset),   data)
        repositioned_bss    = WithPosition(num.add(mem_offset, bss_offset),    bss)
        repositioned_text   = WithPosition(num.add(mem_offset, text_offset),
                                           text(repositioned_rodata, repositioned_data, repositioned_bss))

        ei_mag0       = 0x7F
        ei_mag        = "ELF"
        ei_class      = elfclass.class_64
        ei_data       = elfdata.data_2LSB
        ei_version    = ev.current
        ei_osabi      = osabi.linux
        ei_abiversion = 0
        ei_pad        = bin.unsigned(7, 0)

        e_type      = et.exec
        e_machine   = machine.x86_64
        e_version   = ei_version
        e_entry     = repositioned_text.start
        e_phoff     = num.subtract(phdr, beginning)
        e_shoff     = 0
        e_flags     = 0
        e_ehdrsize  = num.subtract(phdr, ehdr)
        e_phdrsize  = num.subtract(rest, phdr)
        e_phnum     = 1
        e_shentsize = 0
        e_shnum     = 0
        e_shstrndx  = 0

        p_type   = pt.load
        p_offset = 0
        p_vaddr  = mem_offset
        p_paddr  = mem_offset
        p_filesz = binsize
        p_memsz  = binsize
        p_flags  = num.add(pf.x, pf.r)
        p_align  = 0x1000

        :beginning:
        :ehdr:
        bin.u8(      ei_mag0)
        str.ascii(3, ei_mag)
        bin.u8(      ei_class)
        bin.u8(      ei_data)
        bin.u8(      ei_version)
        bin.u8(      ei_osabi)
        bin.u8(      ei_abiversion)
        bin.bin(7,   ei_pad)

        bin.u16(e_type)
        bin.u16(e_machine)
        bin.u32(e_version)
        bin.u64(e_entry)
        bin.u64(e_phoff)
        bin.u64(e_shoff)
        bin.u32(e_flags)
        bin.u16(e_ehdrsize)
        bin.u16(e_phdrsize)
        bin.u16(e_phnum)
        bin.u16(e_shentsize)
        bin.u16(e_shnum)
        bin.u16(e_shstrndx)

        :phdr:
        bin.u32(p_type)
        bin.u64(p_flags)
        bin.u32(p_offset)
        bin.u64(p_vaddr)
        bin.u64(p_paddr)
        bin.u64(p_filesz)
        bin.u64(p_memsz)
        bin.u64(p_align)

        :rest:

        :text_offset:
        repositioned_text()

        # FIXME: put these in actual sections
        :rodata_offset:
        rodata()

        :data_offset:
        data()

        # TODO: properly
        :bss_offset:
        bss()

        :shdr:
        # TODO: section data here

        :end:

"
        # i'd like to move to something a bit simpler. needs:
        # a) ':label: = block' style assignments
        # a.i) with the block's label values fully placed
        # b) out-of-order label label references, at least

        WithPosition(0x00400000, {
            # ELF header in here

            # pass back the placed copies of the blocks so label
            # values can be used
            :placed_text: = text(placed_rodata, placed_data)

            # any labels accessed via these blocks' vars would have
            # the correct label placement values
            :placed_rodata: = rodata()
            :placed_data:   = data()
        })
"

"
            bin.pad_modulo(4, text(placed_rodata, placed_data, placed_bss))

            :placed_rodata: = rodata()
"
    # Now when the length of text becomes known, we simply round up to
    # the nearest multiple of 4, appending zeroes.

    }
}

(std) -> {
    U = std.U
    Ascii = std.Ascii
    Add = std.Add
    Subtract = std.Subtract

    elfclass = {
        class_none = 0
        class_32 = 1
        class_64 = 2
    }
    elfdata = {
        data_none = 0
        data_2LSB = 1
        data_2MSB = 2
    }
    ev = {
        none    = 0
        current = 1
    }
    osabi = {
        sysv    = 0x00
        hpux    = 0x01
        netbsd  = 0x02
        linux   = 0x03
        solaris = 0x06
        aix     = 0x07
        irix    = 0x08
        freebsd = 0x09
        tru64   = 0x0A
        modesto = 0x0B
        openbsd = 0x0C
        openvms = 0x0D
        nsk     = 0x0E
    }
    et = {
        none = 0
        rel  = 1
        exec = 2
        dyn  = 3
        core = 4
    }
    machine = {
        sparc   = 0x02
        x86     = 0x03
        mips    = 0x08
        ppc     = 0x14
        arm     = 0x28
        superh  = 0x2A
        ia_64   = 0x32
        x86_64  = 0x3E
        aarch64 = 0xB7
    }

    pt = {
        null    = 0
        load    = 1
        dynamic = 2
        interp  = 3
        note    = 4
        shlib   = 5
        phdr    = 6
        loos    = 0x60000000
        hios    = 0x6FFFFFFF
        loproc  = 0x70000000
        hiproc  = 0x7FFFFFFF
    }
    pf = {
        x = 0x1
        w = 0x2
        r = 0x4
        maskos   = 0x00FF0000
        maskproc = 0xFF000000
    }

    # TODO: noexec stack
    # TODO: sections, should have:
    # r-x text
    # rw- stack
    # rw- data
    # r-- rodata

    # Thanks to muppetlabs.com for the Whirlwind Tutorial on Creating
    # Really Teensy ELF Executables for Linux :)
    linux_x64 = (rodata, data, text) -> {
        mem_offset = 0x00400000
        binsize = Subtract(end, beginning)

        repositioned_rodata = WithPosition(Add(mem_offset, rodata_offset), rodata)
        repositioned_data   = WithPosition(Add(mem_offset, data_offset),   data)
        repositioned_text   = WithPosition(Add(mem_offset, text_offset),
                                           text(repositioned_rodata, repositioned_data))

        ei_mag0       = 0x7F
        ei_mag        = "ELF"
        ei_class      = elfclass.class_64
        ei_data       = elfdata.data_2LSB
        ei_version    = ev.current
        ei_osabi      = osabi.linux
        ei_abiversion = 0
        ei_pad        = U(7, 0)

        e_type      = et.exec
        e_machine   = machine.x86_64
        e_version   = ei_version
        e_entry     = repositioned_text.start
        e_phoff     = Subtract(phdr, beginning)
        e_shoff     = 0
        e_flags     = 0
        e_ehdrsize  = Subtract(phdr, ehdr)
        e_phdrsize  = Subtract(rest, phdr)
        e_phnum     = 1
        e_shentsize = 0
        e_shnum     = 0
        e_shstrndx  = 0

        p_type   = pt.load
        p_offset = 0
        p_vaddr  = mem_offset
        p_paddr  = mem_offset
        p_filesz = binsize
        p_memsz  = binsize
        p_flags  = Add(pf.x, pf.r)
        p_align  = 0x1000

        :beginning:
        :ehdr:
        U(1,       ei_mag0)
        Ascii(3,   ei_mag)
        U(1,       ei_class)
        U(1,       ei_data)
        U(1,       ei_version)
        U(1,       ei_osabi)
        U(1,       ei_abiversion)
        std.Bin(7, ei_pad)

        U(2, e_type)
        U(2, e_machine)
        U(4, e_version)
        U(8, e_entry)
        U(8, e_phoff)
        U(8, e_shoff)
        U(4, e_flags)
        U(2, e_ehdrsize)
        U(2, e_phdrsize)
        U(2, e_phnum)
        U(2, e_shentsize)
        U(2, e_shnum)
        U(2, e_shstrndx)

        :phdr:
        U(4, p_type)
        U(8, p_flags)
        U(4, p_offset)
        U(8, p_vaddr)
        U(8, p_paddr)
        U(8, p_filesz)
        U(8, p_memsz)
        U(8, p_align)

        :rest:

        :text_offset:
        repositioned_text()

        # FIXME: put these in actual sections
        :rodata_offset:
        rodata()

        :data_offset:
        data()

        :shdr:
        # TODO: section data here

        :end:

"
        # i'd like to move to something a bit simpler. needs:
        # a) ':label: = block' style assignments
        # a.i) with the block's label values fully placed
        # b) out-of-order label label references, at least

        # How does relocatable code work, and importing libraries?

        WithPosition(0x08048000, {
            # ELF header in here

            # pass back the placed copies of the blocks so label
            # values can be used
            text(placed_rodata, placed_data, placed_bss)

            # any labels accessed via these blocks' vars would have
            # the correct label placement values
            :placed_rodata: = rodata()
            :placed_data:   = data()
            :placed_bss:    = bss()
        })

        # this pattern could be quite useful
        block = {
            len = Subtract(end, start)
            #...vars...
            :start:
            #...contents...
            :end:
        }
"

        # XXX: actually, this may not be helpful when it comes to
        # putting data in sections anyway?
        #
        # The sections should be close together, though bear in mind
        # I'll have to align their start point with some 0s, probably
        # to nearest 4 bytes.
        #
        # This situation is closer to
"
            text(placed_rodata, placed_data, placed_bss)

            aligner()
            :placed_rodata: = rodata()
"
    # how on earth to implement aligner() I don't know.
    # A semi-lame way is to do this.
"
            std.pad_modulo(4, text(placed_rodata, placed_data, placed_bss))

            :placed_rodata: = rodata()
"
    # Now when the length of text becomes known, we simply round up to
    # the nearest multiple of 4, appending zeroes.

    }
}

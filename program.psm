#!/usr/bin/env phasm

std = Import("std")
asm = Import("asm_x64")

abstract_elf  = Import("elf")
abstract_sys  = Import("linux-syscall-x64")
abstract_do   = Import("do")
abstract_util = Import("util")

elf  = abstract_elf(std)
sys  = abstract_sys(std, asm)
do   = abstract_do(asm)
util = abstract_util(std, sys)

U = std.U
Bin = std.Bin

rodata = {
    :somestring:  util.utf8("lalala\n\0")
    :hello_world: util.utf8("Hello, world!\n\0")
    :somestring2: util.utf8("hiya\n\0")
}

data = {
    :counter: U(8, 0)
    :space:   Bin(8, "00 00 00 00 00 00 00 00")
}

jge_1b = (to) -> {
    asm.jge_1b(from, to)
    :from:
}
jmp_1b = (to) -> {
    asm.jmp_1b(from, to)
    :from:
}

# n can be up to 256
loop = (n, code) -> {
    asm.mov_eax(U(4, 0))

    :loop:
    asm.cmp_eax_1b(n)
    jge_1b(end)

    asm.push_rax()

    code()

    asm.pop_rax()
    asm.add_eax_1b(1)
    jmp_1b(loop)

    :end:
}

text = (rodata, data) -> {

    # TODO: seccomp2 ourselves down to just sys_write and sys_exit

    loop(3, {
        sys.write(sys.fd_stdout, rodata.somestring2, 5)
    })

    loop(2, {
        sys.write(sys.fd_stdout, rodata.somestring, 7)
    })

    sys.exit(43)

    # signal to the user that this process should be terminated, if
    # not already done so
    :terminated:
    jmp_1b(terminated)
}

elf.linux(rodata, data, text)
